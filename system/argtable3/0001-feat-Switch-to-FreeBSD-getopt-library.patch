From 01ba528135afc14c9c407b541ab320d01bc17c9b Mon Sep 17 00:00:00 2001
From: "Tom G. Huang" <tomghuang@gmail.com>
Date: Sat, 12 Dec 2020 23:33:43 -0800
Subject: [PATCH] feat: Switch to FreeBSD getopt library

Switching to FreeBSD getopt library can resolve two issues:
  1. FreeBSD getopt always uses the 2-Clause BSD, which is compatible
     to GPL. (Although NetBSD has switched to the 2-Clause BSD in
     2008.)
  2. FreeBSD getopt_long provides getopt_long_only, which is critical
     for developers who want to follow the command-line syntax
     convention, which uses a single '-' character for long options.

resolves: #54 #56
---
 LICENSE                        |  12 +-
 src/{getopt.h => arg_getopt.h} |  77 ++--
 src/arg_getopt_long.c          | 659 +++++++++++++++++++++++++++++++++
 src/argtable3.c                |  10 +-
 src/argtable3.h                |   2 +-
 src/getopt_long.c              | 531 --------------------------
 tools/build                    |   4 +-
 tools/build.bat                |   4 +-
 8 files changed, 711 insertions(+), 588 deletions(-)
 rename src/{getopt.h => arg_getopt.h} (51%)
 create mode 100644 src/arg_getopt_long.c
 delete mode 100644 src/getopt_long.c

diff --git argtable3/LICENSE argtable3/LICENSE
index b7853f1..63c7a7f 100644
--- argtable3/LICENSE
+++ argtable3/LICENSE
@@ -25,8 +25,8 @@ ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 
-NetBSD getopt library
-=====================
+FreeBSD getopt library
+======================
 
 Copyright (c) 2000 The NetBSD Foundation, Inc.
 All rights reserved.
@@ -42,13 +42,6 @@ are met:
 2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.
-3. All advertising materials mentioning features or use of this software
-   must display the following acknowledgement:
-       This product includes software developed by the NetBSD
-       Foundation, Inc. and its contributors.
-4. Neither the name of The NetBSD Foundation nor the names of its
-   contributors may be used to endorse or promote products derived
-   from this software without specific prior written permission.
 
 THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
@@ -172,4 +165,3 @@ SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
diff --git argtable3/src/getopt.h argtable3/src/arg_getopt.h
similarity index 51%
rename from src/getopt.h
rename to src/arg_getopt.h
index 2d14394..a67673b 100644
--- argtable3/src/getopt.h
+++ argtable3/src/arg_getopt.h
@@ -1,8 +1,9 @@
-/*	$Id: getopt.h,v 1.1 2009/10/16 19:50:28 rodney Exp rodney $ */
-/*	$OpenBSD: getopt.h,v 1.1 2002/12/03 20:24:29 millert Exp $	*/
 /*	$NetBSD: getopt.h,v 1.4 2000/07/07 10:43:54 ad Exp $	*/
+/*	$FreeBSD$ */
 
-/*
+/*-
+ * SPDX-License-Identifier: BSD-2-Clause-NetBSD
+ *
  * Copyright (c) 2000 The NetBSD Foundation, Inc.
  * All rights reserved.
  *
@@ -17,13 +18,6 @@
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgment:
- *        This product includes software developed by the NetBSD
- *        Foundation, Inc. and its contributors.
- * 4. Neither the name of The NetBSD Foundation nor the names of its
- *    contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
@@ -44,50 +38,51 @@
 #define _GETOPT_H_
 
 /*
- * GNU-like getopt_long() and 4.4BSD getsubopt()/optreset extensions
+ * GNU-like getopt_long()/getopt_long_only() with 4.4BSD optreset extension.
+ * getopt() is declared here too for GNU programs.
  */
-#define no_argument 0
-#define required_argument 1
-#define optional_argument 2
+#define no_argument        0
+#define required_argument  1
+#define optional_argument  2
 
 struct option {
-    /* name of long option */
-    const char* name;
-    /*
-     * one of no_argument, required_argument, and optional_argument:
-     * whether option takes an argument
-     */
-    int has_arg;
-    /* if not NULL, set *flag to val when option found */
-    int* flag;
-    /* if flag not NULL, value to set *flag to; else return value */
-    int val;
+	/* name of long option */
+	const char *name;
+	/*
+	 * one of no_argument, required_argument, and optional_argument:
+	 * whether option takes an argument
+	 */
+	int has_arg;
+	/* if not NULL, set *flag to val when option found */
+	int *flag;
+	/* if flag not NULL, value to set *flag to; else return value */
+	int val;
 };
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-int getopt_long(int, char* const*, const char*, const struct option*, int*);
-int getopt_long_only(int, char* const*, const char*, const struct option*, int*);
-#ifndef _GETOPT_DEFINED
-#define _GETOPT_DEFINED
-int getopt(int, char* const*, const char*);
-int getsubopt(char**, char* const*, char**);
+int	getopt_long(int, char * const *, const char *,
+	const struct option *, int *);
+int	getopt_long_only(int, char * const *, const char *,
+	const struct option *, int *);
+#ifndef _GETOPT_DECLARED
+#define	_GETOPT_DECLARED
+int getopt(int, char * const [], const char *);
 
-extern char* optarg; /* getopt(3) external variables */
-extern int opterr;
-extern int optind;
-extern int optopt;
-extern int optreset;
-extern char* suboptarg; /* getsubopt(3) external variable */
-#endif                  /* _GETOPT_DEFINED */
+extern char *optarg;			/* getopt(3) external variables */
+extern int optind, opterr, optopt;
+#endif
+#ifndef _OPTRESET_DECLARED
+#define	_OPTRESET_DECLARED
+extern int optreset;			/* getopt(3) external variable */
+#endif
 
 #ifdef __cplusplus
 }
 #endif
+ 
 #endif /* !_GETOPT_H_ */
 
-#else
-#include <getopt.h>
-#endif /* ARG_REPLACE_GETOPT */
+#endif /* ARG_REPLACE_GETOPT == 1 */
diff --git argtable3/src/arg_getopt_long.c argtable3/src/arg_getopt_long.c
new file mode 100644
index 0000000..c30d770
--- /dev/null
+++ argtable3/src/arg_getopt_long.c
@@ -0,0 +1,659 @@
+/*	$OpenBSD: getopt_long.c,v 1.26 2013/06/08 22:47:56 millert Exp $	*/
+/*	$NetBSD: getopt_long.c,v 1.15 2002/01/31 22:43:40 tv Exp $	*/
+
+/*
+ * Copyright (c) 2002 Todd C. Miller <Todd.Miller@courtesan.com>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Sponsored in part by the Defense Advanced Research Projects
+ * Agency (DARPA) and Air Force Research Laboratory, Air Force
+ * Materiel Command, USAF, under agreement number F39502-99-1-0512.
+ */
+/*-
+ * Copyright (c) 2000 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Dieter Baron and Thomas Klausner.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "argtable3.h"
+
+#if ARG_REPLACE_GETOPT == 1
+
+#ifndef ARG_AMALGAMATION
+#include "arg_getopt.h"
+#endif
+
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define GNU_COMPATIBLE		/* Be more compatible, configure's use us! */
+
+int	opterr = 1;		/* if error message should be printed */
+int	optind = 1;		/* index into parent argv vector */
+int	optopt = '?';	/* character checked for validity */
+int	optreset;		/* reset getopt */
+char *optarg;		/* argument associated with option */
+
+#define PRINT_ERROR	((opterr) && (*options != ':'))
+
+#define FLAG_PERMUTE	0x01	/* permute non-options to the end of argv */
+#define FLAG_ALLARGS	0x02	/* treat non-options as args to option "-1" */
+#define FLAG_LONGONLY	0x04	/* operate as getopt_long_only */
+
+/* return values */
+#define	BADCH		(int)'?'
+#define	BADARG		((*options == ':') ? (int)':' : (int)'?')
+#define	INORDER 	(int)1
+
+#define	EMSG		""
+
+#ifdef GNU_COMPATIBLE
+#define NO_PREFIX	(-1)
+#define D_PREFIX	0
+#define DD_PREFIX	1
+#define W_PREFIX	2
+#endif
+
+static int getopt_internal(int, char * const *, const char *,
+			   const struct option *, int *, int);
+static int parse_long_options(char * const *, const char *,
+			      const struct option *, int *, int, int);
+static int gcd(int, int);
+static void permute_args(int, int, int, char * const *);
+
+static char *place = EMSG; /* option letter processing */
+
+/* XXX: set optreset to 1 rather than these two */
+static int nonopt_start = -1; /* first non option argument (for permute) */
+static int nonopt_end = -1;   /* first option after non options (for permute) */
+
+/* Error messages */
+static const char recargchar[] = "option requires an argument -- %c";
+static const char illoptchar[] = "illegal option -- %c"; /* From P1003.2 */
+#ifdef GNU_COMPATIBLE
+static int dash_prefix = NO_PREFIX;
+static const char gnuoptchar[] = "invalid option -- %c";
+
+static const char recargstring[] = "option `%s%s' requires an argument";
+static const char ambig[] = "option `%s%.*s' is ambiguous";
+static const char noarg[] = "option `%s%.*s' doesn't allow an argument";
+static const char illoptstring[] = "unrecognized option `%s%s'";
+#else
+static const char recargstring[] = "option requires an argument -- %s";
+static const char ambig[] = "ambiguous option -- %.*s";
+static const char noarg[] = "option doesn't take an argument -- %.*s";
+static const char illoptstring[] = "unknown option -- %s";
+#endif
+
+#ifdef _WIN32
+
+/*
+ * Windows needs warnx().  We change the definition though:
+ *  1. (another) global is defined, opterrmsg, which holds the error message
+ *  2. errors are always printed out on stderr w/o the program name
+ * Note that opterrmsg always gets set no matter what opterr is set to.  The
+ * error message will not be printed if opterr is 0 as usual.
+ */
+
+#include <stdarg.h>
+#include <stdio.h>
+
+#define MAX_OPTERRMSG_SIZE 128
+
+extern char opterrmsg[MAX_OPTERRMSG_SIZE];
+char opterrmsg[MAX_OPTERRMSG_SIZE]; /* buffer for the last error message */
+
+static void warnx(const char* fmt, ...) {
+    va_list ap;
+    va_start(ap, fmt);
+
+    /*
+     * Make sure opterrmsg is always zero-terminated despite the _vsnprintf()
+     * implementation specifics and manually suppress the warning.
+     */
+    memset(opterrmsg, 0, sizeof(opterrmsg));
+    if (fmt != NULL)
+#if (defined(__STDC_LIB_EXT1__) && defined(__STDC_WANT_LIB_EXT1__)) || (defined(__STDC_SECURE_LIB__) && defined(__STDC_WANT_SECURE_LIB__))
+        _vsnprintf_s(opterrmsg, sizeof(opterrmsg), sizeof(opterrmsg) - 1, fmt, ap);
+#else
+        _vsnprintf(opterrmsg, sizeof(opterrmsg) - 1, fmt, ap);
+#endif
+
+    va_end(ap);
+
+#ifdef _MSC_VER
+#pragma warning(suppress : 6053)
+#endif
+    fprintf(stderr, "%s\n", opterrmsg);
+}
+
+#else
+#include <err.h>
+#endif /*_WIN32*/
+/*
+ * Compute the greatest common divisor of a and b.
+ */
+static int
+gcd(int a, int b)
+{
+	int c;
+
+	c = a % b;
+	while (c != 0) {
+		a = b;
+		b = c;
+		c = a % b;
+	}
+
+	return (b);
+}
+
+/*
+ * Exchange the block from nonopt_start to nonopt_end with the block
+ * from nonopt_end to opt_end (keeping the same order of arguments
+ * in each block).
+ */
+static void
+permute_args(int panonopt_start, int panonopt_end, int opt_end,
+	char * const *nargv)
+{
+	int cstart, cyclelen, i, j, ncycle, nnonopts, nopts, pos;
+	char *swap;
+
+	/*
+	 * compute lengths of blocks and number and size of cycles
+	 */
+	nnonopts = panonopt_end - panonopt_start;
+	nopts = opt_end - panonopt_end;
+	ncycle = gcd(nnonopts, nopts);
+	cyclelen = (opt_end - panonopt_start) / ncycle;
+
+	for (i = 0; i < ncycle; i++) {
+		cstart = panonopt_end+i;
+		pos = cstart;
+		for (j = 0; j < cyclelen; j++) {
+			if (pos >= panonopt_end)
+				pos -= nnonopts;
+			else
+				pos += nopts;
+			swap = nargv[pos];
+			/* LINTED const cast */
+			((char **) nargv)[pos] = nargv[cstart];
+			/* LINTED const cast */
+			((char **)nargv)[cstart] = swap;
+		}
+	}
+}
+
+/*
+ * parse_long_options --
+ *	Parse long options in argc/argv argument vector.
+ * Returns -1 if short_too is set and the option does not match long_options.
+ */
+static int
+parse_long_options(char * const *nargv, const char *options,
+	const struct option *long_options, int *idx, int short_too, int flags)
+{
+	char *current_argv, *has_equal;
+#ifdef GNU_COMPATIBLE
+	char *current_dash;
+#endif
+	size_t current_argv_len;
+	int i, match, exact_match, second_partial_match;
+
+	current_argv = place;
+#ifdef GNU_COMPATIBLE
+	switch (dash_prefix) {
+		case D_PREFIX:
+			current_dash = "-";
+			break;
+		case DD_PREFIX:
+			current_dash = "--";
+			break;
+		case W_PREFIX:
+			current_dash = "-W ";
+			break;
+		default:
+			current_dash = "";
+			break;
+	}
+#endif
+	match = -1;
+	exact_match = 0;
+	second_partial_match = 0;
+
+	optind++;
+
+	if ((has_equal = strchr(current_argv, '=')) != NULL) {
+		/* argument found (--option=arg) */
+		current_argv_len = has_equal - current_argv;
+		has_equal++;
+	} else
+		current_argv_len = strlen(current_argv);
+
+	for (i = 0; long_options[i].name; i++) {
+		/* find matching long option */
+		if (strncmp(current_argv, long_options[i].name,
+		    current_argv_len))
+			continue;
+
+		if (strlen(long_options[i].name) == current_argv_len) {
+			/* exact match */
+			match = i;
+			exact_match = 1;
+			break;
+		}
+		/*
+		 * If this is a known short option, don't allow
+		 * a partial match of a single character.
+		 */
+		if (short_too && current_argv_len == 1)
+			continue;
+
+		if (match == -1)	/* first partial match */
+			match = i;
+		else if ((flags & FLAG_LONGONLY) ||
+			 long_options[i].has_arg !=
+			     long_options[match].has_arg ||
+			 long_options[i].flag != long_options[match].flag ||
+			 long_options[i].val != long_options[match].val)
+			second_partial_match = 1;
+	}
+	if (!exact_match && second_partial_match) {
+		/* ambiguous abbreviation */
+		if (PRINT_ERROR)
+			warnx(ambig,
+#ifdef GNU_COMPATIBLE
+			     current_dash,
+#endif
+			     (int)current_argv_len,
+			     current_argv);
+		optopt = 0;
+		return (BADCH);
+	}
+	if (match != -1) {		/* option found */
+		if (long_options[match].has_arg == no_argument
+		    && has_equal) {
+			if (PRINT_ERROR)
+				warnx(noarg,
+#ifdef GNU_COMPATIBLE
+				     current_dash,
+#endif
+				     (int)current_argv_len,
+				     current_argv);
+			/*
+			 * XXX: GNU sets optopt to val regardless of flag
+			 */
+			if (long_options[match].flag == NULL)
+				optopt = long_options[match].val;
+			else
+				optopt = 0;
+#ifdef GNU_COMPATIBLE
+			return (BADCH);
+#else
+			return (BADARG);
+#endif
+		}
+		if (long_options[match].has_arg == required_argument ||
+		    long_options[match].has_arg == optional_argument) {
+			if (has_equal)
+				optarg = has_equal;
+			else if (long_options[match].has_arg ==
+			    required_argument) {
+				/*
+				 * optional argument doesn't use next nargv
+				 */
+				optarg = nargv[optind++];
+			}
+		}
+		if ((long_options[match].has_arg == required_argument)
+		    && (optarg == NULL)) {
+			/*
+			 * Missing argument; leading ':' indicates no error
+			 * should be generated.
+			 */
+			if (PRINT_ERROR)
+				warnx(recargstring,
+#ifdef GNU_COMPATIBLE
+				    current_dash,
+#endif
+				    current_argv);
+			/*
+			 * XXX: GNU sets optopt to val regardless of flag
+			 */
+			if (long_options[match].flag == NULL)
+				optopt = long_options[match].val;
+			else
+				optopt = 0;
+			--optind;
+			return (BADARG);
+		}
+	} else {			/* unknown option */
+		if (short_too) {
+			--optind;
+			return (-1);
+		}
+		if (PRINT_ERROR)
+			warnx(illoptstring,
+#ifdef GNU_COMPATIBLE
+			      current_dash,
+#endif
+			      current_argv);
+		optopt = 0;
+		return (BADCH);
+	}
+	if (idx)
+		*idx = match;
+	if (long_options[match].flag) {
+		*long_options[match].flag = long_options[match].val;
+		return (0);
+	} else
+		return (long_options[match].val);
+}
+
+/*
+ * getopt_internal --
+ *	Parse argc/argv argument vector.  Called by user level routines.
+ */
+static int
+getopt_internal(int nargc, char * const *nargv, const char *options,
+	const struct option *long_options, int *idx, int flags)
+{
+	char *oli;				/* option letter list index */
+	int optchar, short_too;
+	static int posixly_correct = -1;
+
+	if (options == NULL)
+		return (-1);
+
+	/*
+	 * XXX Some GNU programs (like cvs) set optind to 0 instead of
+	 * XXX using optreset.  Work around this braindamage.
+	 */
+	if (optind == 0)
+		optind = optreset = 1;
+
+	/*
+	 * Disable GNU extensions if POSIXLY_CORRECT is set or options
+	 * string begins with a '+'.
+	 */
+	if (posixly_correct == -1 || optreset) {
+#ifdef _WIN32
+		size_t requiredSize;
+		getenv_s(&requiredSize, NULL, 0, "POSIXLY_CORRECT");
+		posixly_correct = requiredSize != 0;
+#else
+		posixly_correct = (getenv("POSIXLY_CORRECT") != NULL);
+#endif
+	}
+
+	if (*options == '-')
+		flags |= FLAG_ALLARGS;
+	else if (posixly_correct || *options == '+')
+		flags &= ~FLAG_PERMUTE;
+	if (*options == '+' || *options == '-')
+		options++;
+
+	optarg = NULL;
+	if (optreset)
+		nonopt_start = nonopt_end = -1;
+start:
+	if (optreset || !*place) {		/* update scanning pointer */
+		optreset = 0;
+		if (optind >= nargc) {          /* end of argument vector */
+			place = EMSG;
+			if (nonopt_end != -1) {
+				/* do permutation, if we have to */
+				permute_args(nonopt_start, nonopt_end,
+				    optind, nargv);
+				optind -= nonopt_end - nonopt_start;
+			}
+			else if (nonopt_start != -1) {
+				/*
+				 * If we skipped non-options, set optind
+				 * to the first of them.
+				 */
+				optind = nonopt_start;
+			}
+			nonopt_start = nonopt_end = -1;
+			return (-1);
+		}
+		if (*(place = nargv[optind]) != '-' ||
+#ifdef GNU_COMPATIBLE
+		    place[1] == '\0') {
+#else
+		    (place[1] == '\0' && strchr(options, '-') == NULL)) {
+#endif
+			place = EMSG;		/* found non-option */
+			if (flags & FLAG_ALLARGS) {
+				/*
+				 * GNU extension:
+				 * return non-option as argument to option 1
+				 */
+				optarg = nargv[optind++];
+				return (INORDER);
+			}
+			if (!(flags & FLAG_PERMUTE)) {
+				/*
+				 * If no permutation wanted, stop parsing
+				 * at first non-option.
+				 */
+				return (-1);
+			}
+			/* do permutation */
+			if (nonopt_start == -1)
+				nonopt_start = optind;
+			else if (nonopt_end != -1) {
+				permute_args(nonopt_start, nonopt_end,
+				    optind, nargv);
+				nonopt_start = optind -
+				    (nonopt_end - nonopt_start);
+				nonopt_end = -1;
+			}
+			optind++;
+			/* process next argument */
+			goto start;
+		}
+		if (nonopt_start != -1 && nonopt_end == -1)
+			nonopt_end = optind;
+
+		/*
+		 * If we have "-" do nothing, if "--" we are done.
+		 */
+		if (place[1] != '\0' && *++place == '-' && place[1] == '\0') {
+			optind++;
+			place = EMSG;
+			/*
+			 * We found an option (--), so if we skipped
+			 * non-options, we have to permute.
+			 */
+			if (nonopt_end != -1) {
+				permute_args(nonopt_start, nonopt_end,
+				    optind, nargv);
+				optind -= nonopt_end - nonopt_start;
+			}
+			nonopt_start = nonopt_end = -1;
+			return (-1);
+		}
+	}
+
+	/*
+	 * Check long options if:
+	 *  1) we were passed some
+	 *  2) the arg is not just "-"
+	 *  3) either the arg starts with -- we are getopt_long_only()
+	 */
+	if (long_options != NULL && place != nargv[optind] &&
+	    (*place == '-' || (flags & FLAG_LONGONLY))) {
+		short_too = 0;
+#ifdef GNU_COMPATIBLE
+		dash_prefix = D_PREFIX;
+#endif
+		if (*place == '-') {
+			place++;		/* --foo long option */
+			if (*place == '\0')
+				return (BADARG);	/* malformed option */
+#ifdef GNU_COMPATIBLE
+			dash_prefix = DD_PREFIX;
+#endif
+		} else if (*place != ':' && strchr(options, *place) != NULL)
+			short_too = 1;		/* could be short option too */
+
+		optchar = parse_long_options(nargv, options, long_options,
+		    idx, short_too, flags);
+		if (optchar != -1) {
+			place = EMSG;
+			return (optchar);
+		}
+	}
+
+	if ((optchar = (int)*place++) == (int)':' ||
+	    (optchar == (int)'-' && *place != '\0') ||
+	    (oli = strchr(options, optchar)) == NULL) {
+		/*
+		 * If the user specified "-" and  '-' isn't listed in
+		 * options, return -1 (non-option) as per POSIX.
+		 * Otherwise, it is an unknown option character (or ':').
+		 */
+		if (optchar == (int)'-' && *place == '\0')
+			return (-1);
+		if (!*place)
+			++optind;
+#ifdef GNU_COMPATIBLE
+		if (PRINT_ERROR)
+			warnx(posixly_correct ? illoptchar : gnuoptchar,
+			      optchar);
+#else
+		if (PRINT_ERROR)
+			warnx(illoptchar, optchar);
+#endif
+		optopt = optchar;
+		return (BADCH);
+	}
+	if (long_options != NULL && optchar == 'W' && oli[1] == ';') {
+		/* -W long-option */
+		if (*place)			/* no space */
+			/* NOTHING */;
+		else if (++optind >= nargc) {	/* no arg */
+			place = EMSG;
+			if (PRINT_ERROR)
+				warnx(recargchar, optchar);
+			optopt = optchar;
+			return (BADARG);
+		} else				/* white space */
+			place = nargv[optind];
+#ifdef GNU_COMPATIBLE
+		dash_prefix = W_PREFIX;
+#endif
+		optchar = parse_long_options(nargv, options, long_options,
+		    idx, 0, flags);
+		place = EMSG;
+		return (optchar);
+	}
+	if (*++oli != ':') {			/* doesn't take argument */
+		if (!*place)
+			++optind;
+	} else {				/* takes (optional) argument */
+		optarg = NULL;
+		if (*place)			/* no white space */
+			optarg = place;
+		else if (oli[1] != ':') {	/* arg not optional */
+			if (++optind >= nargc) {	/* no arg */
+				place = EMSG;
+				if (PRINT_ERROR)
+					warnx(recargchar, optchar);
+				optopt = optchar;
+				return (BADARG);
+			} else
+				optarg = nargv[optind];
+		}
+		place = EMSG;
+		++optind;
+	}
+	/* dump back option letter */
+	return (optchar);
+}
+
+/*
+ * getopt --
+ *	Parse argc/argv argument vector.
+ *
+ * [eventually this will replace the BSD getopt]
+ */
+int
+getopt(int nargc, char * const *nargv, const char *options)
+{
+
+	/*
+	 * We don't pass FLAG_PERMUTE to getopt_internal() since
+	 * the BSD getopt(3) (unlike GNU) has never done this.
+	 *
+	 * Furthermore, since many privileged programs call getopt()
+	 * before dropping privileges it makes sense to keep things
+	 * as simple (and bug-free) as possible.
+	 */
+	return (getopt_internal(nargc, nargv, options, NULL, NULL, 0));
+}
+
+/*
+ * getopt_long --
+ *	Parse argc/argv argument vector.
+ */
+int
+getopt_long(int nargc, char * const *nargv, const char *options,
+	const struct option *long_options, int *idx)
+{
+
+	return (getopt_internal(nargc, nargv, options, long_options, idx,
+	    FLAG_PERMUTE));
+}
+
+/*
+ * getopt_long_only --
+ *	Parse argc/argv argument vector.
+ */
+int
+getopt_long_only(int nargc, char * const *nargv, const char *options,
+	const struct option *long_options, int *idx)
+{
+
+	return (getopt_internal(nargc, nargv, options, long_options, idx,
+	    FLAG_PERMUTE|FLAG_LONGONLY));
+}
+
+#endif /* ARG_REPLACE_GETOPT == 1 */
diff --git argtable3/src/argtable3.c argtable3/src/argtable3.c
index 53e84cb..db9fd91 100644
--- argtable3/src/argtable3.c
+++ argtable3/src/argtable3.c
@@ -34,7 +34,15 @@
 
 #ifndef ARG_AMALGAMATION
 #include "argtable3_private.h"
-#include "getopt.h"
+#if ARG_REPLACE_GETOPT == 1
+#include "arg_getopt.h"
+#else
+#include <getopt.h>
+#endif
+#else
+#if ARG_REPLACE_GETOPT == 0
+#include <getopt.h>
+#endif
 #endif
 
 #ifdef _WIN32
diff --git argtable3/src/argtable3.h argtable3/src/argtable3.h
index 4266874..d3b0540 100644
--- argtable3/src/argtable3.h
+++ argtable3/src/argtable3.h
@@ -47,7 +47,7 @@ extern "C" {
 
 #ifndef ARG_REPLACE_GETOPT
 #define ARG_REPLACE_GETOPT 1 /* use the embedded getopt as the system getopt(3) */
-#endif                       /* ARG_REPLACE_GETOPT */
+#endif /* ARG_REPLACE_GETOPT */
 
 /* bit masks for arg_hdr.flag */
 enum { ARG_TERMINATOR = 0x1, ARG_HASVALUE = 0x2, ARG_HASOPTVALUE = 0x4 };
diff --git argtable3/src/getopt_long.c argtable3/src/getopt_long.c
deleted file mode 100644
index d374afc..0000000
--- argtable3/src/getopt_long.c
+++ /dev/null
@@ -1,531 +0,0 @@
-/*	$Id: getopt_long.c,v 1.1 2009/10/16 19:50:28 rodney Exp rodney $	*/
-/*	$OpenBSD: getopt_long.c,v 1.23 2007/10/31 12:34:57 chl Exp $	*/
-/*	$NetBSD: getopt_long.c,v 1.15 2002/01/31 22:43:40 tv Exp $	*/
-
-/*
- * Copyright (c) 2002 Todd C. Miller <Todd.Miller@courtesan.com>
- *
- * Permission to use, copy, modify, and distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- *
- * Sponsored in part by the Defense Advanced Research Projects
- * Agency (DARPA) and Air Force Research Laboratory, Air Force
- * Materiel Command, USAF, under agreement number F39502-99-1-0512.
- */
-
-/*
- * Copyright (c) 2000 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This code is derived from software contributed to The NetBSD Foundation
- * by Dieter Baron and Thomas Klausner.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "argtable3.h"
-
-#ifndef ARG_AMALGAMATION
-#include "getopt.h"
-#endif
-
-#include <errno.h>
-#include <stdlib.h>
-#include <string.h>
-
-#if ARG_REPLACE_GETOPT == 1
-int opterr = 1;   /* if error message should be printed */
-int optind = 1;   /* index into parent argv vector */
-int optopt = '?'; /* character checked for validity */
-int optreset;     /* reset getopt */
-char* optarg;     /* argument associated with option */
-#endif            /* ARG_REPLACE_GETOPT */
-
-#define PRINT_ERROR ((opterr) && (*options != ':'))
-
-#define FLAG_PERMUTE 0x01  /* permute non-options to the end of argv */
-#define FLAG_ALLARGS 0x02  /* treat non-options as args to option "-1" */
-#define FLAG_LONGONLY 0x04 /* operate as getopt_long_only */
-
-/* return values */
-#define BADCH (int)'?'
-#define BADARG ((*options == ':') ? (int)':' : (int)'?')
-#define INORDER (int)1
-
-#define EMSG ""
-
-#if ARG_REPLACE_GETOPT == 1
-static int getopt_internal(int, char* const*, const char*, const struct option*, int*, int);
-#endif /* ARG_REPLACE_GETOPT */
-static int parse_long_options(char* const*, const char*, const struct option*, int*, int);
-static int gcd(int, int);
-static void permute_args(int, int, int, char* const*);
-
-static char* place = EMSG; /* option letter processing */
-
-/* XXX: set optreset to 1 rather than these two */
-static int nonopt_start = -1; /* first non option argument (for permute) */
-static int nonopt_end = -1;   /* first option after non options (for permute) */
-
-/* Error messages */
-static const char recargchar[] = "option requires an argument -- %c";
-static const char recargstring[] = "option requires an argument -- %s";
-static const char ambig[] = "ambiguous option -- %.*s";
-static const char noarg[] = "option doesn't take an argument -- %.*s";
-static const char illoptchar[] = "unknown option -- %c";
-static const char illoptstring[] = "unknown option -- %s";
-
-#ifdef _WIN32
-
-/* 
- * Windows needs warnx().  We change the definition though:
- *  1. (another) global is defined, opterrmsg, which holds the error message
- *  2. errors are always printed out on stderr w/o the program name
- * Note that opterrmsg always gets set no matter what opterr is set to.  The
- * error message will not be printed if opterr is 0 as usual.
- */
-
-#include <stdarg.h>
-#include <stdio.h>
-
-#define MAX_OPTERRMSG_SIZE 128
-
-extern char opterrmsg[MAX_OPTERRMSG_SIZE];
-char opterrmsg[MAX_OPTERRMSG_SIZE]; /* buffer for the last error message */
-
-static void warnx(const char* fmt, ...) {
-    va_list ap;
-    va_start(ap, fmt);
-
-    /* 
-     * Make sure opterrmsg is always zero-terminated despite the _vsnprintf()
-     * implementation specifics and manually suppress the warning.
-     */
-    memset(opterrmsg, 0, sizeof(opterrmsg));
-    if (fmt != NULL)
-#if (defined(__STDC_LIB_EXT1__) && defined(__STDC_WANT_LIB_EXT1__)) || (defined(__STDC_SECURE_LIB__) && defined(__STDC_WANT_SECURE_LIB__))
-        _vsnprintf_s(opterrmsg, sizeof(opterrmsg), sizeof(opterrmsg) - 1, fmt, ap);
-#else
-        _vsnprintf(opterrmsg, sizeof(opterrmsg) - 1, fmt, ap);
-#endif
-
-    va_end(ap);
-
-#ifdef _MSC_VER
-#pragma warning(suppress : 6053)
-#endif
-    fprintf(stderr, "%s\n", opterrmsg);
-}
-
-#else
-#include <err.h>
-#endif /*_WIN32*/
-
-/*
- * Compute the greatest common divisor of a and b.
- */
-static int gcd(int a, int b) {
-    int c;
-
-    c = a % b;
-    while (c != 0) {
-        a = b;
-        b = c;
-        c = a % b;
-    }
-
-    return (b);
-}
-
-/*
- * Exchange the block from nonopt_start to nonopt_end with the block
- * from nonopt_end to opt_end (keeping the same order of arguments
- * in each block).
- */
-static void permute_args(int panonopt_start, int panonopt_end, int opt_end, char* const* nargv) {
-    int cstart, cyclelen, i, j, ncycle, nnonopts, nopts, pos;
-    char* swap;
-
-    /*
-     * compute lengths of blocks and number and size of cycles
-     */
-    nnonopts = panonopt_end - panonopt_start;
-    nopts = opt_end - panonopt_end;
-    ncycle = gcd(nnonopts, nopts);
-    cyclelen = (opt_end - panonopt_start) / ncycle;
-
-    for (i = 0; i < ncycle; i++) {
-        cstart = panonopt_end + i;
-        pos = cstart;
-        for (j = 0; j < cyclelen; j++) {
-            if (pos >= panonopt_end)
-                pos -= nnonopts;
-            else
-                pos += nopts;
-            swap = nargv[pos];
-            /* LINTED const cast */
-            ((char**)nargv)[pos] = nargv[cstart];
-            /* LINTED const cast */
-            ((char**)nargv)[cstart] = swap;
-        }
-    }
-}
-
-/*
- * parse_long_options --
- *	Parse long options in argc/argv argument vector.
- * Returns -1 if short_too is set and the option does not match long_options.
- */
-static int parse_long_options(char* const* nargv, const char* options, const struct option* long_options, int* idx, int short_too) {
-    char *current_argv, *has_equal;
-    size_t current_argv_len;
-    int i, match;
-
-    current_argv = place;
-    match = -1;
-
-    optind++;
-
-    if ((has_equal = strchr(current_argv, '=')) != NULL) {
-        /* argument found (--option=arg) */
-        current_argv_len = has_equal - current_argv;
-        has_equal++;
-    } else
-        current_argv_len = strlen(current_argv);
-
-    for (i = 0; long_options[i].name; i++) {
-        /* find matching long option */
-        if (strncmp(current_argv, long_options[i].name, current_argv_len))
-            continue;
-
-        if (strlen(long_options[i].name) == current_argv_len) {
-            /* exact match */
-            match = i;
-            break;
-        }
-        /*
-         * If this is a known short option, don't allow
-         * a partial match of a single character.
-         */
-        if (short_too && current_argv_len == 1)
-            continue;
-
-        if (match == -1) /* partial match */
-            match = i;
-        else {
-            /* ambiguous abbreviation */
-            if (PRINT_ERROR)
-                warnx(ambig, (int)current_argv_len, current_argv);
-            optopt = 0;
-            return (BADCH);
-        }
-    }
-    if (match != -1) { /* option found */
-        if (long_options[match].has_arg == no_argument && has_equal) {
-            if (PRINT_ERROR)
-                warnx(noarg, (int)current_argv_len, current_argv);
-            /*
-             * XXX: GNU sets optopt to val regardless of flag
-             */
-            if (long_options[match].flag == NULL)
-                optopt = long_options[match].val;
-            else
-                optopt = 0;
-            return (BADARG);
-        }
-        if (long_options[match].has_arg == required_argument || long_options[match].has_arg == optional_argument) {
-            if (has_equal)
-                optarg = has_equal;
-            else if (long_options[match].has_arg == required_argument) {
-                /*
-                 * optional argument doesn't use next nargv
-                 */
-                optarg = nargv[optind++];
-            }
-        }
-        if ((long_options[match].has_arg == required_argument) && (optarg == NULL)) {
-            /*
-             * Missing argument; leading ':' indicates no error
-             * should be generated.
-             */
-            if (PRINT_ERROR)
-                warnx(recargstring, current_argv);
-            /*
-             * XXX: GNU sets optopt to val regardless of flag
-             */
-            if (long_options[match].flag == NULL)
-                optopt = long_options[match].val;
-            else
-                optopt = 0;
-            --optind;
-            return (BADARG);
-        }
-    } else { /* unknown option */
-        if (short_too) {
-            --optind;
-            return (-1);
-        }
-        if (PRINT_ERROR)
-            warnx(illoptstring, current_argv);
-        optopt = 0;
-        return (BADCH);
-    }
-    if (idx)
-        *idx = match;
-    if (long_options[match].flag) {
-        *long_options[match].flag = long_options[match].val;
-        return (0);
-    } else
-        return (long_options[match].val);
-}
-
-#if ARG_REPLACE_GETOPT == 1
-/*
- * getopt_internal --
- *	Parse argc/argv argument vector.  Called by user level routines.
- */
-static int getopt_internal(int nargc, char* const* nargv, const char* options, const struct option* long_options, int* idx, int flags) {
-    char* oli; /* option letter list index */
-    int optchar, short_too;
-    static int posixly_correct = -1;
-
-    if (options == NULL)
-        return (-1);
-
-    /*
-     * Disable GNU extensions if POSIXLY_CORRECT is set or options
-     * string begins with a '+'.
-     */
-    if (posixly_correct == -1)
-#if defined(_MSC_VER)
-#pragma warning(push)
-#pragma warning(disable : 4996)
-#endif
-        posixly_correct = (getenv("POSIXLY_CORRECT") != NULL);
-#if defined(_MSC_VER)
-#pragma warning(pop)
-#endif
-    if (posixly_correct || *options == '+')
-        flags &= ~FLAG_PERMUTE;
-    else if (*options == '-')
-        flags |= FLAG_ALLARGS;
-    if (*options == '+' || *options == '-')
-        options++;
-
-    /*
-     * XXX Some GNU programs (like cvs) set optind to 0 instead of
-     * XXX using optreset.  Work around this braindamage.
-     */
-    if (optind == 0)
-        optind = optreset = 1;
-
-    optarg = NULL;
-    if (optreset)
-        nonopt_start = nonopt_end = -1;
-start:
-    if (optreset || !*place) { /* update scanning pointer */
-        optreset = 0;
-        if (optind >= nargc) { /* end of argument vector */
-            place = EMSG;
-            if (nonopt_end != -1) {
-                /* do permutation, if we have to */
-                permute_args(nonopt_start, nonopt_end, optind, nargv);
-                optind -= nonopt_end - nonopt_start;
-            } else if (nonopt_start != -1) {
-                /*
-                 * If we skipped non-options, set optind
-                 * to the first of them.
-                 */
-                optind = nonopt_start;
-            }
-            nonopt_start = nonopt_end = -1;
-            return (-1);
-        }
-        if (*(place = nargv[optind]) != '-' || (place[1] == '\0' && strchr(options, '-') == NULL)) {
-            place = EMSG; /* found non-option */
-            if (flags & FLAG_ALLARGS) {
-                /*
-                 * GNU extension:
-                 * return non-option as argument to option 1
-                 */
-                optarg = nargv[optind++];
-                return (INORDER);
-            }
-            if (!(flags & FLAG_PERMUTE)) {
-                /*
-                 * If no permutation wanted, stop parsing
-                 * at first non-option.
-                 */
-                return (-1);
-            }
-            /* do permutation */
-            if (nonopt_start == -1)
-                nonopt_start = optind;
-            else if (nonopt_end != -1) {
-                permute_args(nonopt_start, nonopt_end, optind, nargv);
-                nonopt_start = optind - (nonopt_end - nonopt_start);
-                nonopt_end = -1;
-            }
-            optind++;
-            /* process next argument */
-            goto start;
-        }
-        if (nonopt_start != -1 && nonopt_end == -1)
-            nonopt_end = optind;
-
-        /*
-         * If we have "-" do nothing, if "--" we are done.
-         */
-        if (place[1] != '\0' && *++place == '-' && place[1] == '\0') {
-            optind++;
-            place = EMSG;
-            /*
-             * We found an option (--), so if we skipped
-             * non-options, we have to permute.
-             */
-            if (nonopt_end != -1) {
-                permute_args(nonopt_start, nonopt_end, optind, nargv);
-                optind -= nonopt_end - nonopt_start;
-            }
-            nonopt_start = nonopt_end = -1;
-            return (-1);
-        }
-    }
-
-    /*
-     * Check long options if:
-     *  1) we were passed some
-     *  2) the arg is not just "-"
-     *  3) either the arg starts with -- we are getopt_long_only()
-     */
-    if (long_options != NULL && place != nargv[optind] && (*place == '-' || (flags & FLAG_LONGONLY))) {
-        short_too = 0;
-        if (*place == '-')
-            place++; /* --foo long option */
-        else if (*place != ':' && strchr(options, *place) != NULL)
-            short_too = 1; /* could be short option too */
-
-        optchar = parse_long_options(nargv, options, long_options, idx, short_too);
-        if (optchar != -1) {
-            place = EMSG;
-            return (optchar);
-        }
-    }
-
-    if ((optchar = (int)*place++) == (int)':' || (optchar == (int)'-' && *place != '\0') || (oli = strchr(options, optchar)) == NULL) {
-        /*
-         * If the user specified "-" and  '-' isn't listed in
-         * options, return -1 (non-option) as per POSIX.
-         * Otherwise, it is an unknown option character (or ':').
-         */
-        if (optchar == (int)'-' && *place == '\0')
-            return (-1);
-        if (!*place)
-            ++optind;
-        if (PRINT_ERROR)
-            warnx(illoptchar, optchar);
-        optopt = optchar;
-        return (BADCH);
-    }
-    if (long_options != NULL && optchar == 'W' && oli[1] == ';') {
-        /* -W long-option */
-        if (*place) /* no space */
-            /* NOTHING */;
-        else if (++optind >= nargc) { /* no arg */
-            place = EMSG;
-            if (PRINT_ERROR)
-                warnx(recargchar, optchar);
-            optopt = optchar;
-            return (BADARG);
-        } else /* white space */
-            place = nargv[optind];
-        optchar = parse_long_options(nargv, options, long_options, idx, 0);
-        place = EMSG;
-        return (optchar);
-    }
-    if (*++oli != ':') { /* doesn't take argument */
-        if (!*place)
-            ++optind;
-    } else { /* takes (optional) argument */
-        optarg = NULL;
-        if (*place) /* no white space */
-            optarg = place;
-        else if (oli[1] != ':') {    /* arg not optional */
-            if (++optind >= nargc) { /* no arg */
-                place = EMSG;
-                if (PRINT_ERROR)
-                    warnx(recargchar, optchar);
-                optopt = optchar;
-                return (BADARG);
-            } else
-                optarg = nargv[optind];
-        }
-        place = EMSG;
-        ++optind;
-    }
-    /* dump back option letter */
-    return (optchar);
-}
-
-/*
- * getopt --
- *	Parse argc/argv argument vector.
- *
- * [eventually this will replace the BSD getopt]
- */
-int getopt(int nargc, char* const* nargv, const char* options) {
-    /*
-     * We don't pass FLAG_PERMUTE to getopt_internal() since
-     * the BSD getopt(3) (unlike GNU) has never done this.
-     *
-     * Furthermore, since many privileged programs call getopt()
-     * before dropping privileges it makes sense to keep things
-     * as simple (and bug-free) as possible.
-     */
-    return (getopt_internal(nargc, nargv, options, NULL, NULL, 0));
-}
-#endif /* ARG_REPLACE_GETOPT */
-
-/*
- * getopt_long --
- *	Parse argc/argv argument vector.
- */
-int getopt_long(int nargc, char* const* nargv, const char* options, const struct option* long_options, int* idx) {
-    return (getopt_internal(nargc, nargv, options, long_options, idx, FLAG_PERMUTE));
-}
-
-/*
- * getopt_long_only --
- *	Parse argc/argv argument vector.
- */
-int getopt_long_only(int nargc, char* const* nargv, const char* options, const struct option* long_options, int* idx) {
-    return (getopt_internal(nargc, nargv, options, long_options, idx, FLAG_PERMUTE | FLAG_LONGONLY));
-}
diff --git argtable3/tools/build argtable3/tools/build
index 87710a9..25ebe8f 100755
--- argtable3/tools/build
+++ argtable3/tools/build
@@ -36,8 +36,8 @@ if [ "$1" = "dist" ]; then
       ../src/arg_utils.c \
       ../src/arg_hashtable.c \
       ../src/arg_dstr.c \
-      ../src/getopt.h \
-      ../src/getopt_long.c \
+      ../src/arg_getopt.h \
+      ../src/arg_getopt_long.c \
       ../src/arg_date.c \
       ../src/arg_dbl.c \
       ../src/arg_end.c \
diff --git argtable3/tools/build.bat argtable3/tools/build.bat
index ab3132d..162ebb1 100644
--- argtable3/tools/build.bat
+++ argtable3/tools/build.bat
@@ -72,8 +72,8 @@ cat -B ^
     ..\src\arg_utils.c ^
     ..\src\arg_hashtable.c ^
     ..\src\arg_dstr.c ^
-    ..\src\getopt.h ^
-    ..\src\getopt_long.c ^
+    ..\src\arg_getopt.h ^
+    ..\src\arg_getopt_long.c ^
     ..\src\arg_date.c ^
     ..\src\arg_dbl.c ^
     ..\src\arg_end.c ^
-- 
2.17.1

